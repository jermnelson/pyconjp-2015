{% extends 'yaku.html' %}

{% block main %}
<div class="container">
  <h1>Redis</h1>
  <img src="{{ url_for('static', filename='images/redis.png') }}" 
       class="u-pull-left">
  <p class="intro">
   Redis is a NoSQL key-value data server, recently ranked as one of the top
   technologies for data representation. Going beyond a simple string key and value
   store like Memecache, Redis provides a rich set of data structures like hashes, lists,
   sets, sorted-sets, and most recently a GIS data structures that stores all of the 
   data in a machines RAM while providing two types of persistence to disk, a snapshot
   variant that periodically saves everything to disk and an append-only mode, that logs
   every change to the disk store.  
  </p>
  <div class="row">
   <div class="six columns">
    <h3>Redis Overview</h3>
    <p>
     Redis is an open-source key-value datastore, written in C, with a design goal to
     extremely fast and memory efficient as all of the data is loaded in RAM. Redis also
     provides two modes to persist it's data to disk; a RDF mode that takes a user-defined 
     periodic snapshot and an incremental AOF mode that appends and writes any changes made
     to the data to a log file.
    </p>
    <p>
     The official documentation of Redis is extensive and provides a bonus of providing you
     the OLog efficiency of your Redis commands for specific types of data structures. In 
     this way, you can do an quick estimate of the time efficiency of your data structures in 
     your code.</p>
    <h4 style="width: 50%">O(1) == Good!!</h4> 

    <h5>String and Hash Example</h5>
    <pre>
>>> import redis
>>> local_redis = redis.StrictRedis()
>>> local_redis.set("ichi", 1)
True
>>> local_redis.get("ichi")
b'1'
>>> local_redis.hmset("numbers", {"ichi":1, "ni":2, "san": 3})
>>> local_redis.hgetall("numbers")
>>> local_redis.hgetall("numbers")
{b'ni': b'2', b'san': b'3', b'ichi': b'1'}
>>> local_redis.hget("numbers", "san")
b'3'  
    </pre>
   </div>
   <div class="six columns">
    <h4>Lua Server-side Functions</h4>
    <p>Redis's design pattern for loading and executing server-side Lua scripts was an 
    inspiration for the eventual design for the Linked Data Fragments Server. For these
    Server Side scripts, you can load the script once and a SHA1 hash digest of the script
    is returned that you can use in subsequent function calls instead of sending the entire
    script over the network each time you want to execute the function.</p>
    <h5>Example</h5>
    <pre>
>>> local_redis = redis.StrictRedis()
>>> lua_script = """redis.pcall('incr', 'counter')"""
>>> count_sha1 = local_redis.script_load(lua_script)
>>> count_sha1
'cfb194a8e050ff9f25dc208005798133b5630b51'
>>> local_redis.get('counter')
>>> local_redis.evalsha(count_sha1, 0)
>>> local_redis.get('counter')
b'1'
    </pre>
    <br>
    <div style="background-color: #ad2217; color: white; padding: .5em">
      <h3>(Sorta) Unrelated Aside</h3>
      <p>I'm currently writing a book, <em>Mastering Redis</em> for Packt Publishing
       due out in 2016 that goes into much more detail on using Redis for application 
       development and operations.</p>
    </div> 
   </div> 
  </div>
 <div class="row">
    <h3>Linked Data Fragments<br> in Redis</h3>
    <p class="intro">
    <strong>Triple Pattern Fragment</strong> is 
    made up of data matching a <em>subject-predicate-object</em> triple pattern. 
    For each individual
    subjects, predicates, and objects in a triple, a sha1 hash digest is calculated from the string
    serialization of the each element in the triple and used as a key with the actual entity's value
    stored at that location.
    </p>
    <table>
     <thead>
      <tr>
       <th>Original Value</th>
       <th>SHA1</th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>http://catalog.coloradocollege.edu/4124646</td>
       <td>8b55509dc25092e441bcecb81312f281df945562</td>
      </tr>
      <tr>
        <td>http://www.w3.org/1999/02/22-rdf-syntax-ns#type</td>
        <td>3c197cb1f6842dc41aa48dc8b9032284bcf39a27</td>
      </tr>
      <tr>
       <td>http://bibframe.org/vocab/Work</td>
       <td>5d1377f4476a1cbfb3caea106dc6b0a7d086410a</td>
      </tr>
     </tbody>
    </table>
    <pre>
>>> local_redis.set(
	'5d1377f4476a1cbfb3caea106dc6b0a7d086410a',
	'http://bibframe.org/vocab/Work')
True
>>> local_redis.get(
	'5d1377f4476a1cbfb3caea106dc6b0a7d086410a')
b'http://bibframe.org/vocab/Work'
    </pre>
    <p class="intro"> 
      The initial design of the Linked Data Fragments Server involved first converting 
      all subjects, predicates, and objects in our RDF graphs into SHA1 hashes and then 
      using the resulting digest as a key with the value being the original entity. For each
      triple in the RDF graph, a composite key is constructed with the subject SHA1 hash digest,
      predicate SHA1 hash digest, and object SHA1 hash digest separated by a colon ":".</p>
    <p>To store the triple above, we set an integer value of 1 for the key:<br>
    <strong>8b55509dc25092e441bcecb81312f281df945562:3c197cb1f6842dc41aa48dc8b9032284bcf39a27:5d1377f4476a1cbfb3caea106dc6b0a7d086410a</strong>
    </p>
 </div>
 
</div>
{% include 'snippets/slide-nav.html' %}
</div>
{% endblock %}
